@startuml A02_overview_detailed
title Strategic Planning AI â€“ High-Level Architecture

skinparam componentStyle rectangle
skinparam packageStyle rectangle
skinparam shadowing false
skinparam defaultFontName Arial
skinparam defaultFontSize 11

skinparam rectangle {
  BorderColor<<service>> #000000
  BorderThickness<<service>> 1
}

skinparam rectangle {
  BorderColor<<client>> #000000
  BorderThickness<<client>> 1
}

skinparam rectangle {
  BorderColor<<data>> #000000
  BorderThickness<<data>> 1
}

' === Client / Edge Layer ===
package "Client Layer" as CLIENT {
  [Mock Tester UI\n(FastAPI /ui page)] <<client>> as MOCK_UI
  [External Integrations\n(REST clients, tools)] <<client>> as EXT_CLIENTS
}

' === Service Layer (Microservices) ===
package "Service Layer - Microservices" as SERVICE_LAYER {
  package "Agent Service\nservices/agent_ai\n(Port 8000)" as AGENT_SERVICE {
    [Auth & Session API\n(/api/v1/auth/*)] <<service>> as AUTH_API
    [Chatbot API\n(/api/v1/chatbot/*)] <<service>> as CHAT_API
    [Document Proxy API\n(/api/v1/documents/*)] <<service>> as DOC_PROXY
    [LangGraph Agent\n(orchestrates tools, memory, LLM)] <<service>> as LANGGRAPH
    [Metrics & Tracing\n(Prometheus, Langfuse)] <<service>> as OBS_AGENT
  }
  
  package "Analysis Service\n(Future)\n(Port 8090)" as ANALYSIS_SERVICE {
    [Decision & Governance\n(approvals, explainability)] <<service>> as DECISION
    [Rules & Compliance\n(policy & budget checks)] <<service>> as RULES
    [Scenario Simulation\n(parallel evaluation)] <<service>> as SCENARIO
    [Optimization\n(strategy generation)] <<service>> as OPTIM
  }
}

' === RAG Service ===
package "RAG API Service\nservices/rag_api" as RAG_SERVICE {
  [Upload & Chunking\n(/embed, /embed-upload)] <<service>> as RAG_UPLOAD
  [Vector Search API\n(/query, /query_multiple)] <<service>> as RAG_QUERY
  [Security Middleware\n(JWT validation)] <<service>> as RAG_SEC
  [Async Workers\n(Thread pool, task fanout)] <<service>> as RAG_WORKERS
}

' === Data / Storage ===
database "Postgres + pgvector\n(db container)" <<data>> as PG_DB
[LangGraph Checkpoints\n(checkpoint_* tables)] <<data>> as CHECKPOINTS
[Session & Auth Tables\n(sqlmodel models)] <<data>> as SESSION_DB

database "Neo4j\n(knowledge graph)" <<data>> as NEO4J
[Entity Relationships\n(nodes, edges)] <<data>> as GRAPH_DATA
[Ontology & Schema\n(domain model)] <<data>> as ONTOLOGY

' === External Providers ===
cloud "LLM Provider\n(OpenAI)" as LLM_PROVIDERS
cloud "Embeddings Provider\n(OpenAI)" as EMBEDDINGS
cloud "Observability Stack\n(Prometheus + Grafana)" as OBSERVABILITY
cloud "Langfuse" as LANGFUSE

' === Connections / Data Flows ===
MOCK_UI --> AUTH_API : register / login / create session\n(optional bearer token)
MOCK_UI --> CHAT_API : chat & stream responses
MOCK_UI --> DOC_PROXY : upload docs, list file_ids, preview chunks
EXT_CLIENTS --> AUTH_API
EXT_CLIENTS --> CHAT_API

AUTH_API --> SESSION_DB : create users, guest account, sessions
AUTH_API --> CHECKPOINTS : provision thread IDs

CHAT_API --> LANGGRAPH : invoke workflow per session
CHAT_API --> SESSION_DB : rate limiting, validator (read-only)
CHAT_API --> CHECKPOINTS : persist conversation state

LANGGRAPH --> RAG_QUERY : rag_search tool\n(JWT-authenticated call)
LANGGRAPH --> LLM_PROVIDERS : send prompts / receive completions
LANGGRAPH --> CHECKPOINTS : load/store state snapshots
LANGGRAPH --> DECISION : submit analysis workflows

DOC_PROXY --> RAG_UPLOAD : signed pass-through for files

RAG_UPLOAD --> RAG_WORKERS : async parsing, chunking
RAG_UPLOAD --> EMBEDDINGS : embed documents
RAG_UPLOAD --> PG_DB : store chunks & vectors
RAG_UPLOAD --> NEO4J : extract & store entities/relations

RAG_QUERY --> PG_DB : similarity search (pgvector)
RAG_QUERY --> NEO4J : graph traversal, entity lookup
RAG_QUERY --> RAG_WORKERS

DECISION --> RULES : run compliance checks
DECISION --> SCENARIO : launch scenario experiments
DECISION --> OPTIM : request strategy optimization
RULES --> DECISION : validation results
SCENARIO --> DECISION : scenario metrics & findings
OPTIM --> DECISION : recommended portfolios
SCENARIO --> PG_DB : persist experiment outputs / KPIs
OPTIM --> RAG_UPLOAD : publish strategy summaries

CHAT_API --> OBS_AGENT
CHAT_API --> LANGFUSE
LANGGRAPH --> OBS_AGENT
LANGGRAPH --> LANGFUSE

RAG_SERVICE --> OBSERVABILITY
AGENT_SERVICE --> OBSERVABILITY

SESSION_DB --> PG_DB
CHECKPOINTS --> PG_DB
GRAPH_DATA --> NEO4J
ONTOLOGY --> NEO4J

' === Notes ===
note bottom of SERVICE_LAYER
**Service Layer - Microservices Architecture**
- Agent Service (Port 8000): Main orchestration hub
  * FastAPI + LangGraph + SQLModel
  * Manages authentication, sessions, chat API
  * Orchestrates calls to RAG & Analysis services
- RAG Service (Port 8080): Document processing & search
- Analysis Service (Port 8090): Strategic workflows
  * Decision, rules, scenarios, optimization
  * Future implementation
end note

note bottom of RAG_SERVICE
**Vector Knowledge Service**
- FastAPI + uvicorn
- Handles uploads, chunking, embeddings, vector search
- Requires shared JWT secret with Agent Service
end note

note bottom of PG_DB
**Postgres Database**
- ankane/pgvector image (Docker)
- Stores chat state, sessions, vector embeddings
end note

note bottom of NEO4J
**Neo4j Knowledge Graph**
- Graph database for entity relationships
- Stores domain ontology, business rules
- Enables graph-based reasoning & traversal
end note

@enduml
