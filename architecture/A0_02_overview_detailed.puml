@startuml A0_02_overview_detailed
title Strategic Planning AI â€“ High-Level Architecture

skinparam componentStyle rectangle
skinparam packageStyle rectangle
skinparam shadowing false
skinparam defaultFontName Arial
skinparam defaultFontSize 11

skinparam rectangle {
  BorderColor<<service>> #000000
  BorderThickness<<service>> 1
}

skinparam rectangle {
  BorderColor<<client>> #000000
  BorderThickness<<client>> 1
}

skinparam rectangle {
  BorderColor<<data>> #000000
  BorderThickness<<data>> 1
}

' === Client / Edge Layer ===
package "Client Layer" as CLIENT {
  [Mock Tester UI\n(FastAPI /ui page)] <<client>> as MOCK_UI
  [External Integrations\n(REST clients, tools)] <<client>> as EXT_CLIENTS
}

' === Service Layer (Microservices) ===
package "Service Layer - Microservices" as SERVICE_LAYER {
  package "Agent Service\nservices/agent_ai\n(Port 8000)" as AGENT_SERVICE {
    [Auth & Session API\n(/api/v1/auth/*)] <<service>> as AUTH_API
    [Chatbot API\n(/api/v1/chatbot/*)] <<service>> as CHAT_API
    [Document Proxy API\n(/api/v1/documents/*)] <<service>> as DOC_PROXY
    [LangGraph Agent\n(orchestrates tools, memory, LLM)] <<service>> as LANGGRAPH
    [Metrics & Tracing\n(Prometheus, Langfuse)] <<service>> as OBS_AGENT
  }
  
  package "Analysis Service\n(Future)\n(Port 8090)" as ANALYSIS_SERVICE {
    [Decision & Governance\n(approvals, explainability)] <<service>> as DECISION
    [Rules & Compliance\n(policy & budget checks)] <<service>> as RULES
    [Scenario Simulation\n(parallel evaluation)] <<service>> as SCENARIO
    [Optimization\n(strategy generation)] <<service>> as OPTIM
  }
}

' === RAG Service ===
package "RAG API Service\nservices/rag_api" as RAG_SERVICE {
  [Upload & Chunking\n(/embed, /embed-upload)] <<service>> as RAG_UPLOAD
  [Vector Search API\n(/query, /query_multiple)] <<service>> as RAG_QUERY
  [Security Middleware\n(JWT validation)] <<service>> as RAG_SEC
  [Async Workers\n(Thread pool, task fanout)] <<service>> as RAG_WORKERS
}

' === Data / Storage (Layer 3) ===
package "Knowledge/Data Layer - Storage" as DATA_LAYER {
  database "Postgres\n(relational + vector)" <<data>> as PG_DB {
    [Application Data\n(sessions, users, checkpoints)] <<data>> as APP_DATA
    [University Domain Data\n(courses, students, faculty, budgets)] <<data>> as DOMAIN_DATA
    [Vector Store (pgvector)\n(document chunks + embeddings)] <<data>> as VECTOR_DATA
  }
  
  database "Neo4j\n(knowledge graph)" <<data>> as NEO4J {
    [Entity Nodes\n(people, concepts, strategies)] <<data>> as ENTITIES
    [Relationships\n(edges, properties)] <<data>> as RELATIONS
  }
}

' === External Providers ===
cloud "LLM Provider\n(OpenAI)" as LLM_PROVIDERS
cloud "Embeddings Provider\n(OpenAI)" as EMBEDDINGS
cloud "Observability Stack\n(Prometheus + Grafana)" as OBSERVABILITY
cloud "Langfuse" as LANGFUSE

' === Connections / Data Flows ===
MOCK_UI --> AUTH_API : register / login / create session\n(optional bearer token)
MOCK_UI --> CHAT_API : chat & stream responses
MOCK_UI --> DOC_PROXY : upload docs, list file_ids, preview chunks
EXT_CLIENTS --> AUTH_API
EXT_CLIENTS --> CHAT_API

AUTH_API --> APP_DATA : create users, sessions
AUTH_API --> APP_DATA : provision thread IDs

CHAT_API --> LANGGRAPH : invoke workflow per session
CHAT_API --> APP_DATA : rate limiting
CHAT_API --> APP_DATA : persist conversation state

LANGGRAPH --> RAG_QUERY : rag_search tool (JWT)
LANGGRAPH --> LLM_PROVIDERS : prompts & completions
LANGGRAPH --> APP_DATA : load/store checkpoints
LANGGRAPH --> DECISION : submit analysis workflows

DOC_PROXY --> RAG_UPLOAD : proxy document uploads

RAG_UPLOAD --> RAG_WORKERS : async parsing, chunking
RAG_UPLOAD --> EMBEDDINGS : generate embeddings
RAG_UPLOAD --> VECTOR_DATA : store chunks & vectors
RAG_UPLOAD --> ENTITIES : extract entities (NER)
RAG_UPLOAD --> RELATIONS : store relationships

RAG_QUERY --> VECTOR_DATA : similarity search (pgvector)
RAG_QUERY --> ENTITIES : entity lookup
RAG_QUERY --> RELATIONS : graph traversal

DECISION --> RULES : compliance checks
DECISION --> SCENARIO : launch scenarios
DECISION --> OPTIM : optimization
DECISION --> DOMAIN_DATA : query university data
SCENARIO --> APP_DATA : persist results
OPTIM --> RAG_QUERY : context retrieval

CHAT_API --> OBS_AGENT
LANGGRAPH --> LANGFUSE
RAG_SERVICE --> OBSERVABILITY
AGENT_SERVICE --> OBSERVABILITY

' === Notes ===
note bottom of SERVICE_LAYER
**Service Layer - Microservices Architecture**
- Agent Service (Port 8000): Main orchestration hub
  * FastAPI + LangGraph + SQLModel
  * Manages authentication, sessions, chat API
  * Orchestrates calls to RAG & Analysis services
- RAG Service (Port 8080): Document processing & search
- Analysis Service (Port 8090): Strategic workflows
  * Decision, rules, scenarios, optimization
  * Future implementation
end note

note bottom of RAG_SERVICE
**Vector Knowledge Service**
- FastAPI + uvicorn
- Handles uploads, chunking, embeddings, vector search
- Requires shared JWT secret with Agent Service
end note

note bottom of DATA_LAYER
**Layer 3: Storage Components**
**Postgres (3 data types):**
- Application data (sessions, users, checkpoints)
- University domain data (courses, students, faculty, budgets)
- Vector store (pgvector: document chunks + embeddings)

**Neo4j:**
- Entity nodes (people, concepts, strategies, documents)
- Relationships (edges with properties)
- Domain ontology & business rules
end note

@enduml

